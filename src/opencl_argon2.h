#ifndef __ARGON2_OPENCL_H__
#define __ARGON2_OPENCL_H__

//file: argon2-core.h

/*************************Argon2 internal constants**************************************************/

/* Memory block size in bytes */
#define  ARGON2_BLOCK_SIZE  1024
#define ARGON2_WORDS_IN_BLOCK (ARGON2_BLOCK_SIZE/8)
#define ARGON2_QWORDS_IN_BLOCK 64 /*Dependent values!*/

/* Number of pseudo-random values generated by one call to Blake in Argon2i  to generate reference block positions*/
#define ARGON2_ADDRESSES_IN_BLOCK 128

/* Pre-hashing digest length and its extension*/
#define ARGON2_PREHASH_DIGEST_LENGTH 64
#define ARGON2_PREHASH_SEED_LENGTH 72/*Dependent values!*/


/* Argon2 primitive type */
typedef enum _Argon2_type {
    Argon2_d=0,
    Argon2_i=1,
    Argon2_id=2,
    Argon2_ds=4
} Argon2_type;

/*************************Argon2 internal data types**************************************************/

/*
 * Structure for the (1KB) memory block implemented as 128 64-bit words.
 * Memory blocks can be copied, XORed. Internal words can be accessed by [] (no bounds checking).
 */
typedef struct _block {
    uint64_t v[ARGON2_WORDS_IN_BLOCK];  //size=8B*(1024/8)=1024B  
} block;


/*
 * Argon2 instance: memory pointer, number of passes, amount of memory, type, and derived values. 
 * Used to evaluate the number and location of blocks to construct in each thread
 */
typedef struct _Argon2_instance_t {
    __global block* memory; //Memory pointer
    uint32_t passes; //Number of passes
    uint32_t memory_blocks; //Number of blocks in memory
    uint32_t segment_length;
    uint32_t lane_length;
    uint32_t lanes;
    uint32_t threads;
    Argon2_type type;
    __global uint64_t *Sbox; //S-boxes for Argon2_ds
    bool print_internals;  //whether to print the memory blocks
    __global uint64_t *pseudo_rands;
}Argon2_instance_t;


/*
 * Argon2 position: where we construct the block right now. Used to distribute work between threads.
 */
typedef struct _Argon2_position_t {
    const uint32_t pass;
    const uint32_t lane;
    const uint8_t slice;
    uint32_t index;
}Argon2_position_t;


//file argon2.h

/*************************Argon2 input parameter restrictions**************************************************/

/* Minimum and maximum number of lanes (degree of parallelism) */
#define ARGON2_MIN_LANES 1
#define ARGON2_MAX_LANES 0xFFFFFF

/* Minimum and maximum number of threads */
#define ARGON2_MIN_THREADS 1
#define ARGON2_MAX_THREADS 0xFFFFFF

/* Number of synchronization points between lanes per pass */
#define __ARGON_SYNC_POINTS 4
#define ARGON2_SYNC_POINTS __ARGON_SYNC_POINTS

/* Minimum and maximum digest size in bytes */
#define ARGON2_MIN_OUTLEN 4
#define ARGON2_MAX_OUTLEN 0xFFFFFFFF

/* Minimum and maximum number of memory blocks (each of BLOCK_SIZE bytes) */
#define ARGON2_MIN_MEMORY 2 * __ARGON_SYNC_POINTS // 2 blocks per slice
#define ARGON2_MAX_MEMORY 0xFFFFFFFF // 2^32-1 blocks

/* Minimum and maximum number of passes */
#define ARGON2_MIN_TIME 1
#define ARGON2_MAX_TIME 0xFFFFFFFF

/* Minimum and maximum password length in bytes */
#define ARGON2_MIN_PWD_LENGTH 0
#define ARGON2_MAX_PWD_LENGTH 0xFFFFFFFF

/* Minimum and maximum associated data length in bytes */
#define ARGON2_MIN_AD_LENGTH 0
#define ARGON2_MAX_AD_LENGTH 0xFFFFFFFF

/* Minimum and maximum salt length in bytes */
#define ARGON2_MIN_SALT_LENGTH 8
#define ARGON2_MAX_SALT_LENGTH 0xFFFFFFFF

/* Minimum and maximum key length in bytes */
#define ARGON2_MIN_SECRET 0
#define ARGON2_MAX_SECRET 0xFFFFFFFF

/*****SM-related constants******/
#define ARGON2_SBOX_SIZE (1 << 10)
#define ARGON2_SBOX_MASK ((1<<9) - 1)

/************************* Error codes *********************************************************************************/
typedef enum _Argon2_ErrorCodes {
    ARGON2_OK = 0,

    ARGON2_OUTPUT_PTR_NULL = 1,

    ARGON2_OUTPUT_TOO_SHORT = 2,
    ARGON2_OUTPUT_TOO_LONG = 3,

    ARGON2_PWD_TOO_SHORT = 4,
    ARGON2_PWD_TOO_LONG = 5,

    ARGON2_SALT_TOO_SHORT = 6,
    ARGON2_SALT_TOO_LONG = 7,

    ARGON2_AD_TOO_SHORT = 8,
    ARGON2_AD_TOO_LONG = 9,

    ARGON2_SECRET_TOO_SHORT = 10,
    ARGON2_SECRET_TOO_LONG = 11,

    ARGON2_TIME_TOO_SMALL = 12,
    ARGON2_TIME_TOO_LARGE = 13,

    ARGON2_MEMORY_TOO_LITTLE = 14,
    ARGON2_MEMORY_TOO_MUCH = 15,

    ARGON2_LANES_TOO_FEW = 16,
    ARGON2_LANES_TOO_MANY = 17,

    ARGON2_PWD_PTR_MISMATCH = 18, //NULL ptr with non-zero length
    ARGON2_SALT_PTR_MISMATCH = 19, //NULL ptr with non-zero length
    ARGON2_SECRET_PTR_MISMATCH = 20, //NULL ptr with non-zero length
    ARGON2_AD_PTR_MISMATCH = 21, //NULL ptr with non-zero length

    ARGON2_MEMORY_ALLOCATION_ERROR = 22,

    ARGON2_FREE_MEMORY_CBK_NULL = 23,
    ARGON2_ALLOCATE_MEMORY_CBK_NULL = 24,

    ARGON2_INCORRECT_PARAMETER = 25,
    ARGON2_INCORRECT_TYPE = 26,

    ARGON2_OUT_PTR_MISMATCH = 27,
            
    ARGON2_THREADS_TOO_FEW = 28,
    ARGON2_THREADS_TOO_MANY = 29,

    ARGON2_ERROR_CODES_LENGTH /* Do NOT remove; Do NOT add error codes after this error code */
} Argon2_ErrorCodes;


/********************************************* Argon2 external data structures*************************************************************/

/*
 *****Context: structure to hold Argon2 inputs: 
 * output array and its length, 
 * password and its length,
 * salt and its length,
 * secret and its length,
 * associated data and its length,
 * number of passes, amount of used memory (in KBytes, can be rounded up a bit)
 * number of parallel threads that will be run.
 * All the parameters above affect the output hash value.
 * Additionally, two function pointers can be provided to allocate and deallocate the memory (if NULL, memory will be allocated internally).
 * Also, three flags indicate whether to erase password, secret as soon as they are pre-hashed (and thus not needed anymore), and the entire memory
 ****************************
 Simplest situation: you have output array out[8], password is stored in pwd[32], salt is stored in salt[16], you do not have keys nor associated data.
 You need to spend 1 GB of RAM and you run 5 passes of Argon2d with 4 parallel lanes.
 You want to erase the password, but you're OK with last pass not being erased.
 You want to use the default memory allocator.
 Then you initialize
 Argon2_Context(out,8,pwd,32,salt,16,NULL,0,NULL,0,5,1<<20,4,NULL,NULL,true,false,false).
 */
typedef struct _Argon2_Context {
    uint8_t *out; //output array
    const uint32_t outlen; //digest length

    uint8_t *pwd; //password array
    uint32_t pwdlen; //password length

    const uint8_t *salt; //salt array
    const uint32_t saltlen; //salt length

    uint8_t *secret; //key array
    uint32_t secretlen; //key length

    const uint8_t *ad; //associated data array
    const uint32_t adlen; //associated data length

    const uint32_t t_cost; //number of passes
    const uint32_t m_cost; //amount of memory requested (KB)
    const uint32_t lanes; //number of lanes
    const uint32_t threads; //maximum number of threads

    const bool clear_password; //whether to clear the password array
    const bool clear_secret; //whether to clear the secret array
    const bool clear_memory; //whether to clear the memory after the run
    
    const bool print; //whether to print starting variables, memory blocks, and the tag to the file -- Test vectors only!
    
    __global void *memory;
    __global void *Sbox;
    __global void *pseudo_rands;
} Argon2_Context;


#endif
