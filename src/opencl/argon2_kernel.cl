/*
 * Argon2 source code package
 * 
 * Written by Daniel Dinu and Dmitry Khovratovich, 2015
 * 
 * This work is licensed under a Creative Commons CC0 1.0 License/Waiver.
 * 
 * You should have received a copy of the CC0 Public Domain Dedication along with
 * this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 * modified by Agnieszka Bielec <bielecagnieszka8 at gmail.com>
 */

#include "opencl_device_info.h"
#include "opencl_misc.h"
#include "opencl_string.h"

#define COALESCING 1
#define V ulong8
#define Vsiz 8  //how many times V is bigger than V, this value must be changed if V is changed

//coalescing
#if COALESCING == 1
#define MAP(X) ((X)*get_global_size(0))
#else
#define MAP(X) ((X))
#endif

// BINARY_SIZE, SALT_SIZE, PLAINTEXT_LENGTH is passed with -D during build  

#define ARCH_LITTLE_ENDIAN	1

#include "opencl_endian.h"
#include "opencl_argon2.h"
#include "opencl_blake2.h"
#include "opencl_blake2-round-mka.h"

#define NULL 0

struct argon2_salt {
	uint32_t t_cost;
	uint32_t m_cost;
	uint32_t lanes;
	uint32_t hash_size;
	uint32_t salt_length;
	Argon2_type type;
	char salt[SALT_SIZE];
};

void InitBlockValue(block* b, uint8_t in){
    int i;
    for(i=0;i<ARGON2_WORDS_IN_BLOCK;i++)
      b->v[i]=0;
}

void CopyBlock(void *dst_, const void* src_){
    int i;
    ulong *dst=(ulong *) dst_;
    ulong *src=(ulong *) src_;
    for(i=0; i<ARGON2_WORDS_IN_BLOCK; i++)
      dst[i]=src[i];
}

void CopyBlock_g_map(__global V* dst, const V* src){
    int i,j;
    for(i=0,j=0; i<ARGON2_WORDS_IN_BLOCK/Vsiz; i++,j+=MAP(1))//todo: opt
      dst[j]=src[i];
}

void CopyBlock_pg_map(V * dst, __global const V* src){
    int i;
    for(i=0; i<ARGON2_WORDS_IN_BLOCK/Vsiz; i++)
      dst[i]=src[MAP(i)];
}

void XORBlock_pg_map(V* dst, __global const V* src){
    int i; 
    for(i=0; i<ARGON2_WORDS_IN_BLOCK/Vsiz; ++i){
        dst[i] ^= src[MAP(i)];
    }
}
/*************************Argon2 internal constants**************************************************/

/* Version of the algorithm */
#define ARGON2_VERSION_NUMBER 0x10

/* Memory block size in bytes */
#define  ARGON2_BLOCK_SIZE  1024
#define ARGON2_WORDS_IN_BLOCK (ARGON2_BLOCK_SIZE/8)
#define ARGON2_QWORDS_IN_BLOCK 64 /*Dependent values!*/

/* Number of pseudo-random values generated by one call to Blake in Argon2i  to generate reference block positions*/
#define ARGON2_ADDRESSES_IN_BLOCK 128

/* Pre-hashing digest length and its extension*/
#define ARGON2_PREHASH_DIGEST_LENGTH 64
#define ARGON2_PREHASH_SEED_LENGTH 72/*Dependent values!*/

static int blake2b_long(uchar *out, const void *in, const uint outlen, const ulong inlen)
{
	uint toproduce;
	blake2b_state blake_state;
	if (outlen <= BLAKE2B_OUTBYTES)
	{
		blake2b_init(&blake_state, outlen);
		blake2b_update(&blake_state, (const uchar*)&outlen, sizeof(uint));
		blake2b_update(&blake_state, (const uchar *)in, inlen);
		blake2b_final(&blake_state, out, outlen);
	}
	else
	{
		uchar out_buffer[BLAKE2B_OUTBYTES];
		uchar in_buffer[BLAKE2B_OUTBYTES];
		blake2b_init(&blake_state, BLAKE2B_OUTBYTES);
		blake2b_update(&blake_state, (const uchar*)&outlen, sizeof(uint));
		blake2b_update(&blake_state, (const uchar *)in, inlen);
		blake2b_final(&blake_state, out_buffer, BLAKE2B_OUTBYTES);
		memcpy(out, out_buffer, BLAKE2B_OUTBYTES / 2);
		out += BLAKE2B_OUTBYTES / 2;
		toproduce = outlen - BLAKE2B_OUTBYTES / 2;
		while (toproduce > BLAKE2B_OUTBYTES)
		{
			memcpy(in_buffer, out_buffer, BLAKE2B_OUTBYTES);
			blake2b(out_buffer, in_buffer, 0, BLAKE2B_OUTBYTES, BLAKE2B_OUTBYTES, 0);
			memcpy(out, out_buffer, BLAKE2B_OUTBYTES / 2);
			out += BLAKE2B_OUTBYTES / 2;
			toproduce -= BLAKE2B_OUTBYTES / 2;
		}
		memcpy(in_buffer, out_buffer, BLAKE2B_OUTBYTES);
		blake2b(out_buffer, in_buffer, 0, toproduce, BLAKE2B_OUTBYTES, 0);
		memcpy(out, out_buffer, toproduce);

	}
	return 0;
}


uint32_t IndexAlpha(const Argon2_instance_t* instance, const Argon2_position_t* position, uint32_t pseudo_rand, bool same_lane) {
    /*
     * Pass 0:
     *      This lane : all already finished segments plus already constructed blocks in this segment
     *      Other lanes : all already finished segments
     * Pass 1+:
     *      This lane : (SYNC_POINTS - 1) last segments plus already constructed blocks in this segment
     *      Other lanes : (SYNC_POINTS - 1) last segments 
     */
    uint32_t reference_area_size;
    uint64_t relative_position, start_position, absolute_position;

    if (0 == position->pass) {
        // First pass
        if (0 == position->slice) {
            // First slice
            reference_area_size = position->index - 1; // all but the previous
        } else {
            if (same_lane) {
                // The same lane => add current segment
                reference_area_size = position->slice * instance->segment_length + position->index - 1;
            } else {
                reference_area_size = position->slice * instance->segment_length + ((position->index == 0) ? (-1) : 0);
            }
        }
    } else {
        // Second pass
        if (same_lane) {
            reference_area_size = instance->lane_length - instance->segment_length + position->index - 1;
        } else {
            reference_area_size = instance->lane_length - instance->segment_length + ((position->index == 0) ? (-1) : 0);
        }
    }

    /* 1.2.4. Mapping pseudo_rand to 0..<reference_area_size-1> and produce relative position */
    relative_position = pseudo_rand;
    relative_position = relative_position * relative_position >> 32;
    relative_position = reference_area_size - 1 - (reference_area_size * relative_position >> 32);

    /* 1.2.5 Computing starting position */
    start_position = 0;
    if (0 != position->pass) {
        start_position = (position->slice == ARGON2_SYNC_POINTS - 1) ? 0 : (position->slice + 1) * instance->segment_length;
    }

    /* 1.2.6. Computing absolute position */
    absolute_position = (start_position + relative_position) % instance->lane_length; // absolute position
    return absolute_position;
}

void FillBlock(ulong2* state, const uint8_t *ref_block, uint8_t *next_block, const uint64_t* Sbox) {
    
    ulong2 block_XY[ARGON2_QWORDS_IN_BLOCK];
    uint32_t i;
    
    ulong2 t0,t1;

    for (i = 0; i < ARGON2_QWORDS_IN_BLOCK; i++) {
        block_XY[i] = ((ulong2 *) ref_block)[0];
        ref_block += 16;
    }
    for (i = 0; i < ARGON2_QWORDS_IN_BLOCK; i++) {
        block_XY[i] = state[i] = state[i] ^ block_XY[i];
    }
    
 
    BLAKE2_ROUND_NO_MSG_V(state[0], state[1], state[2], state[3],
            state[4], state[5], state[6], state[7]);

    BLAKE2_ROUND_NO_MSG_V(state[8], state[9], state[10], state[11],
            state[12], state[13], state[14], state[15]);

    BLAKE2_ROUND_NO_MSG_V(state[16], state[17], state[18], state[19],
            state[20], state[21], state[22], state[23]);

    BLAKE2_ROUND_NO_MSG_V(state[24], state[25], state[26], state[27],
            state[28], state[29], state[30], state[31]);

    BLAKE2_ROUND_NO_MSG_V(state[32], state[33], state[34], state[35],
            state[36], state[37], state[38], state[39]);

    BLAKE2_ROUND_NO_MSG_V(state[40], state[41], state[42], state[43],
            state[44], state[45], state[46], state[47]);

    BLAKE2_ROUND_NO_MSG_V(state[48], state[49], state[50], state[51],
            state[52], state[53], state[54], state[55]);

    BLAKE2_ROUND_NO_MSG_V(state[56], state[57], state[58], state[59],
            state[60], state[61], state[62], state[63]);


    BLAKE2_ROUND_NO_MSG_V(state[0], state[8], state[16], state[24],
            state[32], state[40], state[48], state[56]);

    BLAKE2_ROUND_NO_MSG_V(state[1], state[9], state[17], state[25],
            state[33], state[41], state[49], state[57]);

    BLAKE2_ROUND_NO_MSG_V(state[2], state[10], state[18], state[26],
            state[34], state[42], state[50], state[58])

    BLAKE2_ROUND_NO_MSG_V(state[3], state[11], state[19], state[27],
            state[35], state[43], state[51], state[59]);

    BLAKE2_ROUND_NO_MSG_V(state[4], state[12], state[20], state[28],
            state[36], state[44], state[52], state[60]);

    BLAKE2_ROUND_NO_MSG_V(state[5], state[13], state[21], state[29],
            state[37], state[45], state[53], state[61]);

    BLAKE2_ROUND_NO_MSG_V(state[6], state[14], state[22], state[30],
            state[38], state[46], state[54], state[62]);

    BLAKE2_ROUND_NO_MSG_V(state[7], state[15], state[23], state[31],
            state[39], state[47], state[55], state[63]);

    for (i = 0; i < ARGON2_QWORDS_IN_BLOCK; i++) {
        // Feedback
        state[i] = state[i] ^ block_XY[i];
    }
        
    for (i = 0; i < ARGON2_QWORDS_IN_BLOCK; i++) {
        ((ulong2 *) next_block)[0] = state[i] ;
        next_block += 16;
    }
}

void FillBlock_g(ulong2* state, __global const uint8_t *ref_block, __global uint8_t *next_block, __global const uint64_t* Sbox) {
    ulong2 block_XY[ARGON2_QWORDS_IN_BLOCK];
    uint32_t i;
    
    ulong2 t0,t1;
    
#ifdef DS
    uint64_t x = 0;
#endif

    for (i = 0; i < ARGON2_WORDS_IN_BLOCK/Vsiz; i++) {
        ((V *)block_XY)[i] = ((__global V *) ref_block)[0];
        ref_block += MAP(sizeof(V));
    }
    for (i = 0; i < ARGON2_QWORDS_IN_BLOCK; i++) {
        block_XY[i] = state[i] = state[i] ^ block_XY[i];
    }

#ifdef DS
        //x = _mm_extract_epi64(block_XY[0], 0) ^ _mm_extract_epi64(block_XY[ARGON2_QWORDS_IN_BLOCK - 1], 1);
        x = block_XY[0].s0 ^ block_XY[ARGON2_QWORDS_IN_BLOCK - 1].s1;
        for (i = 0; i < 6 * 16; ++i) {
            uint32_t x1 = x >> 32;
            uint32_t x2 = x & 0xFFFFFFFF;
            uint64_t y = Sbox[x1 & ARGON2_SBOX_MASK];
            uint64_t z = Sbox[(x2 & ARGON2_SBOX_MASK) + ARGON2_SBOX_SIZE / 2];
            x = (uint64_t) x1 * (uint64_t) x2;
            x += y;
            x ^= z;
        }
#endif
    

    BLAKE2_ROUND_NO_MSG_V(state[0], state[1], state[2], state[3],
            state[4], state[5], state[6], state[7]);

    BLAKE2_ROUND_NO_MSG_V(state[8], state[9], state[10], state[11],
            state[12], state[13], state[14], state[15]);

    BLAKE2_ROUND_NO_MSG_V(state[16], state[17], state[18], state[19],
            state[20], state[21], state[22], state[23]);

    BLAKE2_ROUND_NO_MSG_V(state[24], state[25], state[26], state[27],
            state[28], state[29], state[30], state[31]);

    BLAKE2_ROUND_NO_MSG_V(state[32], state[33], state[34], state[35],
            state[36], state[37], state[38], state[39]);

    BLAKE2_ROUND_NO_MSG_V(state[40], state[41], state[42], state[43],
            state[44], state[45], state[46], state[47]);

    BLAKE2_ROUND_NO_MSG_V(state[48], state[49], state[50], state[51],
            state[52], state[53], state[54], state[55]);

    BLAKE2_ROUND_NO_MSG_V(state[56], state[57], state[58], state[59],
            state[60], state[61], state[62], state[63]);


    BLAKE2_ROUND_NO_MSG_V(state[0], state[8], state[16], state[24],
            state[32], state[40], state[48], state[56]);

    BLAKE2_ROUND_NO_MSG_V(state[1], state[9], state[17], state[25],
            state[33], state[41], state[49], state[57]);

    BLAKE2_ROUND_NO_MSG_V(state[2], state[10], state[18], state[26],
            state[34], state[42], state[50], state[58])

    BLAKE2_ROUND_NO_MSG_V(state[3], state[11], state[19], state[27],
            state[35], state[43], state[51], state[59]);

    BLAKE2_ROUND_NO_MSG_V(state[4], state[12], state[20], state[28],
            state[36], state[44], state[52], state[60]);

    BLAKE2_ROUND_NO_MSG_V(state[5], state[13], state[21], state[29],
            state[37], state[45], state[53], state[61]);

    BLAKE2_ROUND_NO_MSG_V(state[6], state[14], state[22], state[30],
            state[38], state[46], state[54], state[62]);

    BLAKE2_ROUND_NO_MSG_V(state[7], state[15], state[23], state[31],
            state[39], state[47], state[55], state[63]);

    for (i = 0; i < ARGON2_QWORDS_IN_BLOCK; i++) {
        // Feedback
        state[i] = state[i] ^ block_XY[i];
    }
    
#ifdef DS
      state[0].x+=x;
      state[ARGON2_QWORDS_IN_BLOCK - 1].y+=x;
#endif
    
    for (i = 0; i < ARGON2_WORDS_IN_BLOCK/Vsiz; i++) {
        ((__global V *) next_block)[0] = ((V *)state)[i];
        next_block += MAP(sizeof(V));
    }
}

#ifdef I
void GenerateAddresses(const Argon2_instance_t* instance, const Argon2_position_t* position, __global uint64_t* pseudo_rands) {
    block zero_block, address_block,input_block;
    uint32_t i;
    
    InitBlockValue(&zero_block,0);
    CopyBlock(&address_block,&zero_block);
    CopyBlock(&input_block,&zero_block);
    
    if (instance != NULL && position != NULL) {
        input_block.v[0] = position->pass;
        input_block.v[1] = position->lane;
        input_block.v[2] = position->slice;
        input_block.v[3] = instance->memory_blocks;
        input_block.v[4] = instance->passes;
        input_block.v[5] = instance->type;

        for (i = 0; i < instance->segment_length; ++i) {
            if (i % ARGON2_ADDRESSES_IN_BLOCK == 0) {
                block zero_block, zero2_block;
                input_block.v[6]++;
                InitBlockValue(&zero_block,0);
                InitBlockValue(&zero2_block,0);
                FillBlock((ulong2 *) & zero_block.v, (uint8_t *) & input_block.v, (uint8_t *) & address_block.v, NULL);
                FillBlock((ulong2 *) & zero2_block.v, (uint8_t *) & address_block.v, (uint8_t *) & address_block.v, NULL);
            }
            pseudo_rands[i] = address_block.v[i % ARGON2_ADDRESSES_IN_BLOCK];
        }
    }
}
#endif


void FillSegment(const Argon2_instance_t* instance, Argon2_position_t position) {
   uint64_t pseudo_rand, ref_index, ref_lane;
   uint32_t prev_offset, curr_offset;
   ulong2 state[64];
   __global uint64_t *pseudo_rands;
   uint32_t starting_index;
   uint32_t i;
   bool data_independent_addressing = (instance->type == Argon2_i) || (instance->type == Argon2_id && (position.pass == 0) && (position.slice < ARGON2_SYNC_POINTS / 2));
   
   if (instance == NULL){
       return;
   }    
    
   // Pseudo-random values that determine the reference block position
   pseudo_rands = instance->pseudo_rands;
   
   /*if (pseudo_rands == NULL) {
       return;
   }*/
   
   
#ifdef I
   GenerateAddresses(instance, &position, pseudo_rands);
#endif

   starting_index = 0;
   if ((0 == position.pass) && (0 == position.slice)) {
       starting_index = 2; // we have already generated the first two blocks
   }

   // Offset of the current block
   curr_offset = position.lane * instance->lane_length + position.slice * instance->segment_length + starting_index;
   if (0 == curr_offset % instance->lane_length) {
       // Last block in this lane
       prev_offset = curr_offset + instance->lane_length - 1;
   } else {
       // Previous block
       prev_offset = curr_offset - 1;
   }  
   CopyBlock_pg_map((V*) state, (__global V*) ((instance->memory + MAP(prev_offset*(ARGON2_WORDS_IN_BLOCK/Vsiz)))));
   for (i = starting_index; i < instance->segment_length; ++i, ++curr_offset, ++prev_offset) {
       __global V *ref_block, *curr_block;
       /*1.1 Rotating prev_offset if needed */
       if (curr_offset % instance->lane_length == 1) {
           prev_offset = curr_offset - 1;
       }
       

       /* 1.2 Computing the index of the reference block */
       /* 1.2.1 Taking pseudo-random value from the previous block */
       if (data_independent_addressing) {
           pseudo_rand = pseudo_rands[i];
       } else {
	   #if Vsiz > 1
	   pseudo_rand = (instance->memory[MAP(prev_offset*(ARGON2_WORDS_IN_BLOCK/Vsiz))]).s0;
	   #else
	   pseudo_rand = instance->memory[MAP(prev_offset*(ARGON2_WORDS_IN_BLOCK/Vsiz))];
	   #endif
       }

       /* 1.2.2 Computing the lane of the reference block */
       ref_lane = ((pseudo_rand >> 32)) % instance->lanes;
       if ((position.pass == 0) && (position.slice == 0)) {
           // Can not reference other lanes yet
           ref_lane = position.lane;
       }

       /* 1.2.3 Computing the number of possible reference block within the lane. */
       position.index = i;
       ref_index = IndexAlpha(instance, &position, pseudo_rand & 0xFFFFFFFF, ref_lane == position.lane);

       /* 2 Creating a new block */
       ref_block = instance->memory + MAP((instance->lane_length * ref_lane + ref_index)*(ARGON2_WORDS_IN_BLOCK/Vsiz));
       curr_block = instance->memory + MAP(curr_offset*(ARGON2_WORDS_IN_BLOCK/Vsiz));
       FillBlock_g((ulong2 *)state, (__global uint8_t *) ref_block, (__global uint8_t *) curr_block, instance->Sbox);
   }   
}

void GenerateSbox(Argon2_instance_t* instance) {
    uint32_t i;
    block zero_block, out_block, start_block;
    if (instance == NULL) {
        return;
    }
    InitBlockValue(&zero_block,0);
    out_block = zero_block;
    //start_block = instance->memory[0];
    CopyBlock_pg_map((V*) &start_block, (__global V*) instance->memory);
    
    for (i = 0; i < ARGON2_SBOX_SIZE / ARGON2_WORDS_IN_BLOCK; ++i) {
        block zero_block, zero2_block;
        InitBlockValue(&zero_block,0);
        InitBlockValue(&zero2_block,0);
        FillBlock((ulong2*) zero_block.v, (uint8_t*) start_block.v, (uint8_t*) out_block.v, NULL);
        FillBlock((ulong2*) zero2_block.v, (uint8_t*) out_block.v, (uint8_t*) start_block.v, NULL);
        memcpy_g(instance->Sbox + i * ARGON2_WORDS_IN_BLOCK, start_block.v, ARGON2_BLOCK_SIZE);
    }
}

void Finalize(const Argon2_Context *context, Argon2_instance_t* instance) {
    if (context != NULL && instance != NULL) {
        uint32_t l;
        block blockhash;
        CopyBlock_pg_map((V*) &blockhash, (__global V*) instance->memory+ MAP((instance->lane_length - 1)*(ARGON2_WORDS_IN_BLOCK/Vsiz)));

        // XOR the last blocks
        for (l = 1; l < instance->lanes; ++l) {
            uint32_t last_block_in_lane = l * instance->lane_length + (instance->lane_length - 1);
            XORBlock_pg_map((V*) &blockhash,(__global V*) instance->memory + MAP(last_block_in_lane*(ARGON2_WORDS_IN_BLOCK/Vsiz)));

        }

        // Hash the result
        blake2b_long(context->out, (uint8_t*) blockhash.v, context->outlen, ARGON2_BLOCK_SIZE);
    }
}

void FillMemoryBlocks(Argon2_instance_t* instance) {
    uint32_t r;
    if (instance == NULL) {
        return;
    }
    for (r = 0; r < instance->passes; ++r) {
        uint8_t s;
        if (Argon2_ds == instance->type) {
            GenerateSbox(instance);
        }
        for (s = 0; s < ARGON2_SYNC_POINTS; ++s) {
            uint32_t l;

            for (l = 0; l < instance->lanes; ++l) {
                Argon2_position_t position = {r,l,s,0};

                FillSegment(instance, position);
            }
        }
    }
}

int ValidateInputs(const Argon2_Context* context) {
    if (NULL == context) {
        return ARGON2_INCORRECT_PARAMETER;
    }

    if (NULL == context->out) {
        return ARGON2_OUTPUT_PTR_NULL;
    }

    /* Validate output length */
    if (ARGON2_MIN_OUTLEN > context->outlen) {
        return ARGON2_OUTPUT_TOO_SHORT;
    }
    if (ARGON2_MAX_OUTLEN < context->outlen) {
        return ARGON2_OUTPUT_TOO_LONG;
    }

    /* Validate password length */
    if (NULL == context->pwd) {
        if (0 != context->pwdlen) {
            return ARGON2_PWD_PTR_MISMATCH;
        }
    } else {
        if (ARGON2_MIN_PWD_LENGTH != 0 && ARGON2_MIN_PWD_LENGTH > context->pwdlen) {
            return ARGON2_PWD_TOO_SHORT;
        }
        if (ARGON2_MAX_PWD_LENGTH < context->pwdlen) {
            return ARGON2_PWD_TOO_LONG;
        }
    }

    /* Validate salt length */
    if (NULL == context->salt) {
        if (0 != context->saltlen) {
            return ARGON2_SALT_PTR_MISMATCH;
        }
    } else {
        if (ARGON2_MIN_SALT_LENGTH > context->saltlen) {
            return ARGON2_SALT_TOO_SHORT;
        }
        if (ARGON2_MAX_SALT_LENGTH < context->saltlen) {
            return ARGON2_SALT_TOO_LONG;
        }
    }

    /* Validate secret length */
    if (NULL == context->secret) {
        if (0 != context->secretlen) {
            return ARGON2_SECRET_PTR_MISMATCH;
        }
    } else {
        //warning: pointless comparison of unsigned integer with zero
        /*
        if (ARGON2_MIN_SECRET > context->secretlen) {
            return ARGON2_SECRET_TOO_SHORT;
        }
        */
        if (ARGON2_MAX_SECRET < context->secretlen) {
            return ARGON2_SECRET_TOO_LONG;
        }
    }

    /* Validate associated data */
    if (NULL == context->ad) {
        if (0 != context->adlen) {
            return ARGON2_AD_PTR_MISMATCH;
        }
    } else {
        //ARGON2_MIN_AD_LENGTH, ARGON2_MAX_AD_LENGTH are 0 and one compiler make warnings
        /*
        if (ARGON2_MIN_AD_LENGTH > context->adlen) {
            return ARGON2_AD_TOO_SHORT;
        }
        if (ARGON2_MAX_AD_LENGTH < context->adlen) {
            return ARGON2_AD_TOO_LONG;
        }*/
    }

    /* Validate memory cost */
    if (ARGON2_MIN_MEMORY > context->m_cost) {
        return ARGON2_MEMORY_TOO_LITTLE;
    }
    if (ARGON2_MAX_MEMORY < context->m_cost) {
        return ARGON2_MEMORY_TOO_MUCH;
    }

    /* Validate time cost */
    if (ARGON2_MIN_TIME > context->t_cost) {
        return ARGON2_TIME_TOO_SMALL;
    }
    if (ARGON2_MAX_TIME < context->t_cost) {
        return ARGON2_TIME_TOO_LARGE;
    }

    /* Validate lanes */
    if (ARGON2_MIN_LANES > context->lanes) {
        return ARGON2_LANES_TOO_FEW;
    }
    if (ARGON2_MAX_LANES < context->lanes) {
        return ARGON2_LANES_TOO_MANY;
    }
    
    /* Validate threads */
    if (ARGON2_MIN_THREADS > context->threads) {
        return ARGON2_THREADS_TOO_FEW;
    }
    if (ARGON2_MAX_THREADS < context->threads) {
        return ARGON2_THREADS_TOO_MANY;
    }

    return ARGON2_OK;
}

void FillFirstBlocks(uint8_t* blockhash, const Argon2_instance_t* instance) {
    // Make the first and second block in each lane as G(H0||i||0) or G(H0||i||1)
    uint32_t l;
    block tmp;
    
    for (l = 0; l < instance->lanes; ++l) {
        store32(blockhash+ARGON2_PREHASH_DIGEST_LENGTH,0);
        store32(blockhash+ARGON2_PREHASH_DIGEST_LENGTH + 4,l);
	
	blake2b_long((uint8_t*) (tmp.v), blockhash, ARGON2_BLOCK_SIZE, ARGON2_PREHASH_SEED_LENGTH);
	CopyBlock_g_map((__global V*) instance->memory+MAP((l * instance->lane_length)*(ARGON2_WORDS_IN_BLOCK/Vsiz)),(V*) &tmp);
        store32(blockhash+ARGON2_PREHASH_DIGEST_LENGTH,1);
	
	blake2b_long((uint8_t*) (tmp.v), blockhash, ARGON2_BLOCK_SIZE, ARGON2_PREHASH_SEED_LENGTH);
	CopyBlock_g_map((__global V*) instance->memory+MAP((l * instance->lane_length + 1)*(ARGON2_WORDS_IN_BLOCK/Vsiz)),(V*) &tmp);
    }
}

void InitialHash(uint8_t* blockhash, Argon2_Context* context, Argon2_type type) {
    blake2b_state BlakeHash;
    uint8_t value[sizeof (uint32_t)];

    if (NULL == context || NULL == blockhash) {
        return;
    }

    blake2b_init(&BlakeHash, ARGON2_PREHASH_DIGEST_LENGTH);

    store32(&value, context->lanes);
    blake2b_update(&BlakeHash, (const uint8_t*) &value, sizeof (value));

    store32(&value, context->outlen);
    blake2b_update(&BlakeHash, (const uint8_t*) &value, sizeof (value));

    store32(&value, context->m_cost);
    blake2b_update(&BlakeHash, (const uint8_t*) &value, sizeof (value));

    store32(&value, context->t_cost);
    blake2b_update(&BlakeHash, (const uint8_t*) &value, sizeof (value));

    store32(&value, ARGON2_VERSION_NUMBER);
    blake2b_update(&BlakeHash, (const uint8_t*) &value, sizeof (value));

    store32(&value, (uint32_t) type);
    blake2b_update(&BlakeHash, (const uint8_t*) &value, sizeof (value));

    store32(&value, context->pwdlen);
    blake2b_update(&BlakeHash, (const uint8_t*) &value, sizeof (value));
    if (context->pwd != NULL) {
        blake2b_update(&BlakeHash, (const uint8_t*) context->pwd, context->pwdlen);
    }

    store32(&value, context->saltlen);
    blake2b_update(&BlakeHash, (const uint8_t*) &value, sizeof (value));
    if (context->salt != NULL) {
        blake2b_update(&BlakeHash, (const uint8_t*) context->salt, context->saltlen);
    }

    store32(&value, context->secretlen);
    blake2b_update(&BlakeHash, (const uint8_t*) &value, sizeof (value));
    if (context->secret != NULL) {
        blake2b_update(&BlakeHash, (const uint8_t*) context->secret, context->secretlen);
    }

    store32(&value, context->adlen);
    blake2b_update(&BlakeHash, (const uint8_t*) &value, sizeof (value));
    if (context->ad != NULL) {
        blake2b_update(&BlakeHash, (const uint8_t*) context->ad, context->adlen);
    }
    blake2b_final(&BlakeHash, blockhash, ARGON2_PREHASH_DIGEST_LENGTH);
}

int Initialize(Argon2_instance_t* instance, Argon2_Context* context) {
    int result = ARGON2_OK;
    uint8_t blockhash[ARGON2_PREHASH_SEED_LENGTH];
    
    if (instance == NULL || context == NULL)
        return ARGON2_INCORRECT_PARAMETER;

    instance->memory=context->memory;


    if (ARGON2_OK != result) {
        return result;
    }

    InitialHash(blockhash, context, instance->type);
    FillFirstBlocks(blockhash, instance);

    return ARGON2_OK;
}

int Argon2Core(Argon2_Context* context, Argon2_type type) {
    uint32_t segment_length;
    uint32_t memory_blocks;
    /* 1. Validate all inputs */
    int result = ValidateInputs(context);
    Argon2_instance_t instance = { NULL, context->t_cost, 0, 0, 
        0, context->lanes, context->threads, type, NULL, 0};

    if (ARGON2_OK != result) {
        return result;
    }
    if (Argon2_d != type && Argon2_i != type && Argon2_id != type && Argon2_ds != type) {
        return ARGON2_INCORRECT_TYPE;
    }

    /* 2. Align memory size */
    // Minimum memory_blocks = 8L blocks, where L is the number of lanes
    memory_blocks = context->m_cost;
    if (memory_blocks < 2 * ARGON2_SYNC_POINTS * context->lanes) {
        memory_blocks = 2 * ARGON2_SYNC_POINTS * context->lanes;
    }
    segment_length = memory_blocks / (context->lanes * ARGON2_SYNC_POINTS);
    // Ensure that all segments have equal length
    memory_blocks = segment_length * (context->lanes * ARGON2_SYNC_POINTS);

    instance.memory_blocks=memory_blocks;
    instance.segment_length=segment_length;
    instance.lane_length=segment_length * ARGON2_SYNC_POINTS;
    

    /* 3. Initialization: Hashing inputs, allocating memory, filling first blocks */
    result = Initialize(&instance, context);
    if (ARGON2_OK != result) {
        return result;
    }
    
    instance.pseudo_rands=(__global uint64_t*)context->pseudo_rands;
    instance.Sbox=(__global uint64_t*)context->Sbox;
    
    /* 4. Filling memory */
    FillMemoryBlocks(&instance);
    /* 5. Finalization */
    Finalize(context, &instance);
    return ARGON2_OK;
}


__kernel void argon2_crypt_kernel(
    __global const uchar * in,
    __global const uint * lengths,
    __global uchar *out,
    __global struct argon2_salt *salt,
    __global V *memory,
    __global ulong *pseudo_rands,
    __global ulong *Sbox
)
{
	int i;
	uint gid = get_global_id(0);
	
  	uint8_t* default_ad_ptr = NULL;
	uint32_t default_ad_length = 0;
	uint8_t* default_secret_ptr = NULL;
	uint32_t default_secret_length = 0;
	uint8_t default_parallelism = 1;
	bool c_p=false;
	bool c_s=false;
	bool c_m=false;
	bool pr=false;
	
#if COALESCING == 0
	size_t mem_size;
#endif
	size_t pseudo_rands_size;
	uint32_t memory_blocks, segment_length;
	
	uint32_t hash_size=(uint32_t) salt->hash_size;
	uint32_t m_cost=salt->m_cost;
	uint32_t t_cost=salt->t_cost;
	uint32_t lanes=salt->lanes;
	uint32_t salt_length=salt->salt_length;
	
	uint32_t inlen = lengths[gid];
	
	in += gid*PLAINTEXT_LENGTH;
	out += gid * BINARY_SIZE;
	
	//computing memory size
	memory_blocks = m_cost;
	if (memory_blocks < 2 * ARGON2_SYNC_POINTS * lanes) {
	  memory_blocks = 2 * ARGON2_SYNC_POINTS * lanes;
	}
	segment_length = memory_blocks / (lanes * ARGON2_SYNC_POINTS);
	// Ensure that all segments have equal length
	memory_blocks = segment_length * (lanes * ARGON2_SYNC_POINTS);

#if COALESCING == 0
	mem_size= sizeof(block)*memory_blocks;
#endif
	pseudo_rands_size=sizeof(uint64_t)*segment_length;
				
	

#if COALESCING == 1
	memory+=gid;
#else
	memory+=mem_size/sizeof(V)*gid;
#endif
	
	pseudo_rands+=pseudo_rands_size/sizeof(ulong)*gid;
	if(salt->type==Argon2_ds)
	   Sbox+=(sizeof(ulong)*ARGON2_SBOX_SIZE)/sizeof(ulong)*gid;
	
	
	uchar real_salt[SALT_SIZE];
	for (i=0;i<salt_length;i++)
	  real_salt[i]=salt->salt[i];
	
	uchar pass[PLAINTEXT_LENGTH];
	for(i=0;i<inlen;i++)
	  pass[i]=in[i];
	
	uchar out_[BINARY_SIZE];
	

	Argon2_Context context = {(uint8_t*) out_, hash_size,
            (uint8_t*) pass, (uint32_t) inlen,
            (uint8_t*) real_salt, salt_length,
            default_ad_ptr, default_ad_length,
            default_secret_ptr, default_secret_length,
            t_cost, m_cost, lanes, default_parallelism,
	c_p,c_s,c_m,pr, memory, Sbox, pseudo_rands};
	Argon2Core(&context, salt->type);
	
	for(i=0;i<hash_size;i++)
	{
	  out[i]=out_[i];
	}
}
 
